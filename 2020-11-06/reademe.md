import加载的模块分为四个通用类别：

- 使用python编写的代码（.py文件）；
- 已被编译为共享库或DLL的C或C++扩展；
- 包好一组模块的包
- 使用C编写并链接到python解释器的内置模块；

我们学习过的math这个包就是使用C编写并链接到python解释器的内置模块

我们原来学习的程序代码量都比较少，所以放到一个文件中我们还能清晰的阅读，但是我们在写实际上的工程程序代码量就会很大，如果这时候我们还将程序都放到一个文件中就会变得很难去维护

所以我们需要将程序拆分为多个模块，然后通过调用完成各个模块之间的联动

还有一种情况是我们写了一个程序，这个程序比如说是创建文件的程序，通用性很强，为了避免重复去写这个程序我们就可以将他封装为一个模块，然后我们要创建文件的时候就调用这个模块

什么是包呢？包就是集成了多个模块的文件夹

创建一个做加法的程序

这个做加法的程序只能传递两个参数，我们再改改传多个参数，直接用`sum`函数将他们加起来，然后我要在我的程序中测试一下这个程序，我想看看我这样写对不对

运行之后是没有问题的

那么我就调用一下它，结果就很奇怪，为什么出现了我们测试的结果呢

原来啊，我们在导入这个包的时候我们的Python就会将这个包进行一次加载，那么它加载这个程序的时候发现我们调用了这个程序，所以就去执行代码了

那么这个问题怎么解决呢？在python中呢有一个叫内建变量的东西，这个内建变量呢就像我们的内置函数，是python给我们准备好的，我们直接调用就行，在内建变量中有一个叫`__name__`的变量，我们来看看这个变量，当我们在这个mod1程序中调用的时候这个变量呢就是`__main__`，并且类型是字符串，那我们调用这个包看看

这时候这个变量就变为了我们调用它的程序的名字，那么我们就可以写一个条件语句

```python
def add(*args):
    return sum(args)


if __name__ == "__main__":
    s = add(1, 2, 3)
    print(s)
```

好的，这样的话只有我们在这个程序中测试的时候会执行了，我们在外部调用的时候就不会执行了。

我现在又创建了一个程序，获取输入并输出值的，那么我们的主要程序和他们放在一起就不方便管理，我把他们都放到`util`这个文件夹中

这时候再想访问我们可以使用import来访问，但是这样我们包中程序很多的话就不方便，我们可以使用from……import……

这样就能快速的导入我们想要的包